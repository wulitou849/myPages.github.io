<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <!-- ç§»åŠ¨ç«¯è§†å£é…ç½®ï¼šé€‚é…åˆ˜æµ·å±/å…¨é¢å±ï¼Œç¦æ­¢ç¼©æ”¾ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>3Dç²’å­ç›¸ç‰‡æŒ‚é’© - ç‚«é…·ç‰ˆ</title>
    <style>
        /* ä½¿ç”¨è§†å£å•ä½ï¼ˆvw/vhï¼‰å®ç°å®Œå…¨å“åº”å¼å¸ƒå±€ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            height: 100dvh; /* åŠ¨æ€è§†å£é«˜åº¦ï¼Œé€‚é…ç§»åŠ¨ç«¯æµè§ˆå™¨åœ°å€æ  */
            overflow: hidden;
            background: #000;
            touch-action: none; /* ç¦æ­¢é»˜è®¤è§¦æ‘¸è¡Œä¸ºï¼ˆæ»šåŠ¨ã€ç¼©æ”¾ç­‰ï¼‰ */
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
            /* é€‚é…åˆ˜æµ·å±ï¼šä½¿ç”¨å®‰å…¨åŒºåŸŸ */
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }

        /* 3Dç”»å¸ƒå®¹å™¨ï¼šå æ»¡å±å¹•å¯è§†åŒºåŸŸï¼ˆé¡¶éƒ¨ç•™æŒ‰é’®ç©ºé—´ï¼‰ */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            z-index: 1;
        }

        /* é¡¶éƒ¨æ§åˆ¶æ ï¼šä½¿ç”¨vwå•ä½ï¼Œé€‚é…å„ç§å±å¹• */
        #control-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            z-index: 100;
            background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
            padding: 2.5vw;
            padding-top: calc(2.5vw + env(safe-area-inset-top));
            display: flex;
            flex-direction: column;
            gap: 2.5vw; /* æŒ‰é’®é—´è·â‰¥10px */
            align-items: center;
        }

        /* ä¸Šä¼ æŒ‰é’®ï¼šæœ€å°44pxé«˜åº¦ï¼ˆç¬¦åˆç§»åŠ¨ç«¯è§¦æ§æ ‡å‡†ï¼‰ */
        .btn {
            min-height: 12vw; /* åœ¨360pxå±å¹•ä¸Šâ‰ˆ43pxï¼Œåœ¨æ›´å¤§å±å¹•ä¸Šæ›´å¤§ */
            min-width: 12vw;
            padding: 2.5vw 5vw;
            border: none;
            border-radius: 6vw;
            font-size: 4vw;
            font-weight: bold;
            color: #fff;
            cursor: pointer;
            outline: none;
            transition: transform 0.1s, opacity 0.2s;
            touch-action: manipulation; /* ä¼˜åŒ–è§¦æ‘¸å“åº” */
            user-select: none;
            -webkit-tap-highlight-color: transparent; /* ç§»é™¤ç‚¹å‡»é«˜äº® */
        }

        .btn:active {
            transform: scale(0.95);
            opacity: 0.8;
        }

        /* ä¸Šä¼ æŒ‰é’®æ ·å¼ */
        .upload-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            box-shadow: 0 0.5vw 2vw rgba(102, 126, 234, 0.4);
        }

        /* å‚æ•°è°ƒèŠ‚æŒ‰é’®ç»„ */
        .param-group {
            display: flex;
            gap: 2.5vw;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
        }

        .param-btn {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            border: 0.3vw solid rgba(255, 255, 255, 0.3);
        }

        .param-btn.active {
            background: rgba(102, 126, 234, 0.6);
            border-color: rgba(102, 126, 234, 0.8);
        }

        /* éšè—æ–‡ä»¶è¾“å…¥ */
        input[type="file"] {
            display: none;
        }

        /* åŠ è½½æç¤º */
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 4vw;
            text-align: center;
            z-index: 200;
            display: none;
            pointer-events: none;
            text-shadow: 0 0 2vw rgba(102, 126, 234, 0.8);
        }

        /* æ“ä½œæç¤ºï¼ˆé¦–æ¬¡ä½¿ç”¨æ—¶æ˜¾ç¤ºï¼‰ */
        #hint {
            position: fixed;
            bottom: 5vh;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.6);
            font-size: 3vw;
            text-align: center;
            z-index: 50;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.5);
            padding: 2vw 4vw;
            border-radius: 4vw;
            backdrop-filter: blur(10px);
        }

        /* ç²’å­æ•°é‡æ˜¾ç¤º */
        #particle-count {
            position: fixed;
            top: 15vh;
            right: 2.5vw;
            color: rgba(255, 255, 255, 0.5);
            font-size: 3vw;
            z-index: 50;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <!-- 3Dç”»å¸ƒå®¹å™¨ -->
    <div id="canvas-container"></div>

    <!-- é¡¶éƒ¨æ§åˆ¶é¢æ¿ -->
    <div id="control-panel">
        <!-- å›¾ç‰‡ä¸Šä¼ æŒ‰é’® -->
        <label class="btn upload-btn" for="imageInput">
            ğŸ“· é€‰æ‹©ç…§ç‰‡
        </label>
        <input type="file" id="imageInput" accept="image/*" capture="environment">
        
        <!-- å‚æ•°è°ƒèŠ‚æŒ‰é’®ç»„ -->
        <div class="param-group">
            <button class="btn param-btn" data-param="particles" data-value="1000">1000ç²’å­</button>
            <button class="btn param-btn" data-param="particles" data-value="2000">2000ç²’å­</button>
            <button class="btn param-btn active" data-param="particles" data-value="3000">3000ç²’å­</button>
        </div>
    </div>

    <!-- åŠ è½½æç¤º -->
    <div id="loading">æ­£åœ¨è§£æå›¾ç‰‡...</div>

    <!-- æ“ä½œæç¤º -->
    <div id="hint">
        ğŸ‘† å•æŒ‡æ‹–æ‹½æ—‹è½¬ | ğŸ¤ åŒæŒ‡ç¼©æ”¾ | â¸ï¸ é•¿æŒ‰æš‚åœ
    </div>

    <!-- ç²’å­æ•°é‡æ˜¾ç¤º -->
    <div id="particle-count">ç²’å­: 3000</div>

    <!-- Three.jsåº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // ==================== è®¾å¤‡æ€§èƒ½æ£€æµ‹ ====================
        function detectDevicePerformance() {
            // æ£€æµ‹ç¡¬ä»¶å¹¶å‘æ•°ã€å†…å­˜ç­‰æŒ‡æ ‡
            const cores = navigator.hardwareConcurrency || 4;
            const memory = navigator.deviceMemory || 4; // GB
            const pixelRatio = window.devicePixelRatio || 1;
            
            // æ€§èƒ½åˆ†çº§ï¼šhigh/medium/low
            let performance = 'medium';
            if (cores >= 8 && memory >= 6 && pixelRatio >= 2) {
                performance = 'high';
            } else if (cores <= 4 || memory <= 3) {
                performance = 'low';
            }
            
            return {
                level: performance,
                cores: cores,
                memory: memory,
                pixelRatio: pixelRatio
            };
        }

        const devicePerf = detectDevicePerformance();
        console.log('è®¾å¤‡æ€§èƒ½:', devicePerf);

        // ==================== ç§»åŠ¨ç«¯é…ç½® ====================
        const CONFIG = {
            // ç²’å­æ•°é‡é…ç½®ï¼ˆå¯è°ƒèŠ‚ï¼‰
            particleCount: 3000,
            minParticles: 1000,
            maxParticles: 3000,
            
            // æ€§èƒ½ä¼˜åŒ–ï¼šå›¾ç‰‡å‹ç¼©å°ºå¯¸
            imageMaxSize: 150,
            
            // 3Dåœºæ™¯é…ç½®
            cameraDistance: 400,
            particleSize: 3.0,
            sphereRadius: 150,
            
            // äº¤äº’å‚æ•°
            rotationSpeed: 0.5,
            zoomSpeed: 0.1,
            longPressDelay: 500,
            
            // åŠ¨ç”»å‚æ•°
            autoRotateSpeed: 0.003,
            breathingSpeed: 0.002,
            breathingRange: 0.05,
            
            // ç‰¹æ•ˆå¼€å…³ï¼ˆæ ¹æ®è®¾å¤‡æ€§èƒ½ï¼‰
            enableTrail: devicePerf.level !== 'low', // æ‹–å°¾æ®‹å½±
            enableNeonOutline: devicePerf.level !== 'low', // éœ“è™¹æè¾¹
            enableStarField: true, // æ˜Ÿç©ºåº•çº¹ï¼ˆä½é…ä¹Ÿå¼€å¯ï¼Œæ•°é‡å°‘ï¼‰
            enableTwinkle: true, // é—ªçƒæ•ˆæœ
            enableLayers: true, // Zè½´åˆ†å±‚
            
            // ç‰¹æ•ˆå‚æ•°
            trailCount: 3, // æ®‹å½±æ•°é‡
            trailFade: 0.3, // æ®‹å½±è¡°å‡
            neonOutlineBrightness: 1.3, // éœ“è™¹æè¾¹äº®åº¦å€æ•°
            twinkleRatio: 0.1, // é—ªçƒç²’å­æ¯”ä¾‹
            layerCount: 10, // Zè½´å±‚æ•°
            maxBrightness: 0.8, // æœ€å¤§äº®åº¦ï¼ˆé¿å…è¿‡æ›ï¼‰
            starFieldCount: devicePerf.level === 'high' ? 500 : 200, // æ˜Ÿç©ºç²’å­æ•°
            
            // åŠ¨ç”»æ—¶é•¿ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰
            colorTransition: 0.1, // è‰²å½©è¿‡æ¸¡æ—¶é—´
            zoomAnimation: 0.2, // ç¼©æ”¾åŠ¨ç”»æ—¶é—´
            explosionDuration: 0.3, // çˆ†ç‚¸åŠ¨ç”»æ—¶é—´
            loadAnimation: 1.0 // åŠ è½½åŠ¨ç”»æ—¶é—´
        };

        // ==================== å…¨å±€å˜é‡ ====================
        let scene, camera, renderer, particlesMesh, starFieldMesh;
        let particleData = []; // ç²’å­æ•°æ®æ•°ç»„
        let starFieldData = []; // æ˜Ÿç©ºåº•çº¹æ•°æ®
        let isPaused = false;
        let time = 0;
        let lastFrameTime = performance.now();
        let animationState = {
            isExploding: false,
            explosionTime: 0,
            isLoading: false,
            loadTime: 0,
            zoomTarget: null,
            zoomStart: null,
            zoomTime: 0
        };

        // è§¦æ‘¸äº¤äº’çŠ¶æ€
        let touchState = {
            isDragging: false,
            isZooming: false,
            lastTouchX: 0,
            lastTouchY: 0,
            lastDistance: 0,
            longPressTimer: null,
            touches: [],
            dragVelocity: { x: 0, y: 0 }, // æ‹–æ‹½é€Ÿåº¦ï¼ˆç”¨äºæ®‹å½±ï¼‰
            lastDragTime: 0
        };

        // æ‹–å°¾æ®‹å½±ç³»ç»Ÿ
        let trailSystem = {
            trails: [], // æ®‹å½±æ•°ç»„
            maxTrails: CONFIG.trailCount
        };

        // DOMå…ƒç´ 
        const canvasContainer = document.getElementById('canvas-container');
        const imageInput = document.getElementById('imageInput');
        const loadingDiv = document.getElementById('loading');
        const hintDiv = document.getElementById('hint');
        const particleCountDiv = document.getElementById('particle-count');

        // ==================== å·¥å…·å‡½æ•° ====================
        // çº¿æ€§æ’å€¼å‡½æ•°ï¼ˆå…¼å®¹Three.js r128ï¼‰
        function lerp(a, b, t) {
            return a + (b - a) * t;
        }

        // RGBè½¬HSV
        function rgbToHsv(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const delta = max - min;
            
            let h = 0;
            if (delta !== 0) {
                if (max === r) h = ((g - b) / delta) % 6;
                else if (max === g) h = (b - r) / delta + 2;
                else h = (r - g) / delta + 4;
            }
            h = Math.round(h * 60);
            if (h < 0) h += 360;
            
            const s = max === 0 ? 0 : delta / max;
            const v = max;
            
            return { h, s, v };
        }

        // HSVè½¬RGB
        function hsvToRgb(h, s, v) {
            const c = v * s;
            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
            const m = v - c;
            
            let r, g, b;
            if (h < 60) { r = c; g = x; b = 0; }
            else if (h < 120) { r = x; g = c; b = 0; }
            else if (h < 180) { r = 0; g = c; b = x; }
            else if (h < 240) { r = 0; g = x; b = c; }
            else if (h < 300) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }
            
            return {
                r: Math.min(1, (r + m) * CONFIG.maxBrightness),
                g: Math.min(1, (g + m) * CONFIG.maxBrightness),
                b: Math.min(1, (b + m) * CONFIG.maxBrightness)
            };
        }

        // æ£€æµ‹æ˜¯å¦ä¸ºè½®å»“è¾¹ç¼˜ï¼ˆç®€åŒ–ç‰ˆï¼šåŸºäºç›¸é‚»åƒç´ å·®å¼‚ï¼‰
        function isEdgePixel(imageData, x, y, width, height, threshold = 30) {
            if (x === 0 || y === 0 || x === width - 1 || y === height - 1) return true;
            
            const idx = (y * width + x) * 4;
            const r = imageData[idx];
            const g = imageData[idx + 1];
            const b = imageData[idx + 2];
            const a = imageData[idx + 3];
            
            if (a < 128) return false; // é€æ˜åŒºåŸŸä¸ç®—è¾¹ç¼˜
            
            // æ£€æŸ¥ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘çš„åƒç´ å·®å¼‚
            const neighbors = [
                { x: x - 1, y }, { x: x + 1, y },
                { x, y: y - 1 }, { x, y: y + 1 }
            ];
            
            for (const n of neighbors) {
                if (n.x < 0 || n.x >= width || n.y < 0 || n.y >= height) continue;
                const nIdx = (n.y * width + n.x) * 4;
                const nr = imageData[nIdx];
                const ng = imageData[nIdx + 1];
                const nb = imageData[nIdx + 2];
                
                const diff = Math.abs(r - nr) + Math.abs(g - ng) + Math.abs(b - nb);
                if (diff > threshold) return true;
            }
            
            return false;
        }

        // ==================== åˆå§‹åŒ– ====================
        function init() {
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            // åˆ›å»ºç›¸æœº
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 2000);
            camera.position.z = CONFIG.cameraDistance;

            // åˆ›å»ºæ¸²æŸ“å™¨ï¼ˆGPUä¼˜åŒ–ï¼‰
            renderer = new THREE.WebGLRenderer({ 
                antialias: devicePerf.level === 'high',
                alpha: true,
                powerPreference: devicePerf.level === 'high' ? "high-performance" : "low-power"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, devicePerf.level === 'high' ? 2 : 1.5));
            canvasContainer.appendChild(renderer.domElement);

            // äº‹ä»¶ç›‘å¬
            window.addEventListener('resize', onWindowResize);
            imageInput.addEventListener('change', handleImageUpload);
            document.querySelectorAll('.param-btn').forEach(btn => {
                btn.addEventListener('click', handleParamChange);
            });

            // è§¦æ‘¸å’Œé¼ æ ‡äº‹ä»¶
            setupTouchEvents();
            setupMouseEvents();

            // åˆ›å»ºæ˜Ÿç©ºåº•çº¹
            if (CONFIG.enableStarField) {
                createStarField();
            }

            // åˆ›å»ºé»˜è®¤ç²’å­æ•ˆæœ
            createDefaultParticles();
            
            // å¯åŠ¨åŠ¨ç”»å¾ªç¯
            animate();
            
            // 3ç§’åéšè—æç¤º
            setTimeout(() => {
                hintDiv.style.opacity = '0';
                setTimeout(() => hintDiv.style.display = 'none', 500);
            }, 3000);
        }

        // ==================== åˆ›å»ºæ˜Ÿç©ºåº•çº¹ ====================
        function createStarField() {
            const positions = [];
            const colors = [];
            const count = CONFIG.starFieldCount;
            
            for (let i = 0; i < count; i++) {
                // éšæœºåˆ†å¸ƒåœ¨æ›´å¤§çš„çƒé¢ä¸Š
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const radius = CONFIG.sphereRadius * 2.5;
                
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);
                
                positions.push(x, y, z);
                
                // ä½äº®åº¦ç™½è‰²/è“è‰²
                const brightness = 0.1 + Math.random() * 0.2;
                colors.push(brightness, brightness * 0.8, brightness);
                
                starFieldData.push({ x, y, z });
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 1.5,
                map: createGlowTexture(),
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.3
            });
            
            starFieldMesh = new THREE.Points(geometry, material);
            scene.add(starFieldMesh);
        }

        // ==================== è§¦æ‘¸äº‹ä»¶å¤„ç† ====================
        function setupTouchEvents() {
            renderer.domElement.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchState.touches = Array.from(e.touches);
                
                if (e.touches.length === 1) {
                    touchState.isDragging = true;
                    touchState.lastTouchX = e.touches[0].clientX;
                    touchState.lastTouchY = e.touches[0].clientY;
                    touchState.lastDragTime = performance.now();
                    touchState.dragVelocity = { x: 0, y: 0 };
                    
                    touchState.longPressTimer = setTimeout(() => {
                        handleLongPress(e.touches[0]);
                    }, CONFIG.longPressDelay);
                } else if (e.touches.length === 2) {
                    touchState.isDragging = false;
                    touchState.isZooming = true;
                    clearTimeout(touchState.longPressTimer);
                    
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    touchState.lastDistance = Math.sqrt(dx * dx + dy * dy);
                    
                    // ç¼©æ”¾åŠ¨ç”»å¼€å§‹
                    animationState.zoomStart = camera.position.length();
                }
            }, { passive: false });

            renderer.domElement.addEventListener('touchmove', (e) => {
                e.preventDefault();
                touchState.touches = Array.from(e.touches);
                
                if (touchState.isDragging && e.touches.length === 1) {
                    clearTimeout(touchState.longPressTimer);
                    
                    const now = performance.now();
                    const deltaTime = (now - touchState.lastDragTime) / 1000;
                    const deltaX = e.touches[0].clientX - touchState.lastTouchX;
                    const deltaY = e.touches[0].clientY - touchState.lastTouchY;
                    
                    // è®¡ç®—æ‹–æ‹½é€Ÿåº¦ï¼ˆç”¨äºæ®‹å½±ï¼‰
                    if (deltaTime > 0) {
                        touchState.dragVelocity.x = deltaX / deltaTime;
                        touchState.dragVelocity.y = deltaY / deltaTime;
                    }
                    
                    // æ—‹è½¬ç›¸æœº
                    const spherical = new THREE.Spherical();
                    spherical.setFromVector3(camera.position);
                    spherical.theta -= deltaX * CONFIG.rotationSpeed * 0.01;
                    spherical.phi += deltaY * CONFIG.rotationSpeed * 0.01;
                    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                    
                    camera.position.setFromSpherical(spherical);
                    camera.lookAt(0, 0, 0);
                    
                    // æ·»åŠ æ‹–å°¾æ®‹å½±
                    if (CONFIG.enableTrail && Math.abs(deltaX) + Math.abs(deltaY) > 2) {
                        addTrail();
                    }
                    
                    touchState.lastTouchX = e.touches[0].clientX;
                    touchState.lastTouchY = e.touches[0].clientY;
                    touchState.lastDragTime = now;
                } else if (touchState.isZooming && e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    const delta = touchState.lastDistance - distance;
                    const newDistance = camera.position.length() + delta * CONFIG.zoomSpeed;
                    const clampedDistance = Math.max(200, Math.min(800, newDistance));
                    
                    animationState.zoomTarget = clampedDistance;
                    animationState.zoomTime = 0;
                    
                    camera.position.normalize().multiplyScalar(clampedDistance);
                    camera.lookAt(0, 0, 0);
                    
                    touchState.lastDistance = distance;
                }
            }, { passive: false });

            renderer.domElement.addEventListener('touchend', (e) => {
                e.preventDefault();
                clearTimeout(touchState.longPressTimer);
                
                if (e.touches.length === 0) {
                    touchState.isDragging = false;
                    touchState.isZooming = false;
                    touchState.touches = [];
                    touchState.dragVelocity = { x: 0, y: 0 };
                } else if (e.touches.length === 1) {
                    touchState.isZooming = false;
                    touchState.isDragging = true;
                    touchState.lastTouchX = e.touches[0].clientX;
                    touchState.lastTouchY = e.touches[0].clientY;
                }
            }, { passive: false });
        }

        // ==================== é•¿æŒ‰å¤„ç†ï¼ˆèšæ‹¢+çˆ†ç‚¸ï¼‰ ====================
        function handleLongPress(touch) {
            togglePause();
            
            if (!isPaused) {
                // é•¿æŒ‰ç‚¹è½¬æ¢ä¸º3Dåæ ‡
                const vector = new THREE.Vector3();
                vector.set(
                    (touch.clientX / window.innerWidth) * 2 - 1,
                    -(touch.clientY / window.innerHeight) * 2 + 1,
                    0.5
                );
                vector.unproject(camera);
                const dir = vector.sub(camera.position).normalize();
                const distance = -camera.position.z / dir.z;
                const pos = camera.position.clone().add(dir.multiplyScalar(distance));
                
                // è§¦å‘èšæ‹¢åŠ¨ç”»
                startGatherAnimation(pos);
            }
        }

        // ==================== èšæ‹¢åŠ¨ç”» ====================
        function startGatherAnimation(targetPos) {
            // ä¿å­˜åŸå§‹ä½ç½®
            particleData.forEach(p => {
                p.gatherTarget = targetPos.clone();
                p.gatherStart = new THREE.Vector3(p.baseX, p.baseY, p.baseZ);
                p.gatherTime = 0;
            });
            
            // å¼€å§‹èšæ‹¢
            const gatherDuration = 0.3;
            const startTime = performance.now();
            
            function gatherStep() {
                const elapsed = (performance.now() - startTime) / 1000;
                const progress = Math.min(1, elapsed / gatherDuration);
                
                // ç¼“åŠ¨å‡½æ•°ï¼ˆeaseOutï¼‰
                const eased = 1 - Math.pow(1 - progress, 3);
                
                particleData.forEach(p => {
                    if (p.gatherTarget) {
                        p.x = lerp(p.gatherStart.x, p.gatherTarget.x, eased);
                        p.y = lerp(p.gatherStart.y, p.gatherTarget.y, eased);
                        p.z = lerp(p.gatherStart.z, p.gatherTarget.z, eased);
                    }
                });
                
                if (progress < 1) {
                    requestAnimationFrame(gatherStep);
                } else {
                    // èšæ‹¢å®Œæˆï¼Œå¼€å§‹çˆ†ç‚¸
                    startExplosionAnimation();
                }
            }
            
            gatherStep();
        }

        // ==================== çˆ†ç‚¸åŠ¨ç”» ====================
        function startExplosionAnimation() {
            animationState.isExploding = true;
            animationState.explosionTime = 0;
            
            particleData.forEach(p => {
                p.explosionVelocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20
                );
                p.explosionStart = new THREE.Vector3(p.x, p.y, p.z);
            });
        }

        // ==================== æ‹–å°¾æ®‹å½±ç³»ç»Ÿ ====================
        function addTrail() {
            if (!CONFIG.enableTrail || !particlesMesh) return;
            
            // åˆ›å»ºæ®‹å½±å‰¯æœ¬
            const trail = {
                mesh: particlesMesh.clone(),
                opacity: 0.5,
                time: 0
            };
            
            // åº”ç”¨å½“å‰ç²’å­ä½ç½®
            const positions = particlesMesh.geometry.attributes.position.array;
            trail.mesh.geometry.attributes.position.array = new Float32Array(positions);
            trail.mesh.geometry.attributes.position.needsUpdate = true;
            
            // è°ƒæ•´æè´¨é€æ˜åº¦
            trail.mesh.material = trail.mesh.material.clone();
            trail.mesh.material.opacity = 0.5;
            
            scene.add(trail.mesh);
            trailSystem.trails.push(trail);
            
            // é™åˆ¶æ®‹å½±æ•°é‡
            if (trailSystem.trails.length > CONFIG.maxTrails) {
                const oldTrail = trailSystem.trails.shift();
                scene.remove(oldTrail.mesh);
                oldTrail.mesh.geometry.dispose();
                oldTrail.mesh.material.dispose();
            }
        }

        // ==================== é¼ æ ‡äº‹ä»¶å¤„ç†ï¼ˆæ¡Œé¢ç«¯å…¼å®¹ï¼‰ ====================
        function setupMouseEvents() {
            let isMouseDown = false;
            let lastMouseX = 0;
            let lastMouseY = 0;

            renderer.domElement.addEventListener('mousedown', (e) => {
                isMouseDown = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isMouseDown) {
                    const deltaX = e.clientX - lastMouseX;
                    const deltaY = e.clientY - lastMouseY;
                    
                    const spherical = new THREE.Spherical();
                    spherical.setFromVector3(camera.position);
                    spherical.theta -= deltaX * CONFIG.rotationSpeed * 0.01;
                    spherical.phi += deltaY * CONFIG.rotationSpeed * 0.01;
                    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                    
                    camera.position.setFromSpherical(spherical);
                    camera.lookAt(0, 0, 0);
                    
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                }
            });

            renderer.domElement.addEventListener('mouseup', () => {
                isMouseDown = false;
            });

            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY * 0.01;
                const newDistance = camera.position.length() + delta * 50;
                const clampedDistance = Math.max(200, Math.min(800, newDistance));
                camera.position.normalize().multiplyScalar(clampedDistance);
                camera.lookAt(0, 0, 0);
            }, { passive: false });
        }

        // ==================== ç²’å­ç³»ç»Ÿ ====================
        // åˆ›å»ºé«˜çº§å‘å…‰çº¹ç†ï¼ˆå¤šè¾¹å½¢/æ¸å˜å…‰çƒï¼‰
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            const size = 128; // æé«˜åˆ†è¾¨ç‡ä»¥è·å¾—æ›´å¥½çš„å‘å…‰æ•ˆæœ
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            // ç»˜åˆ¶å¤šè¾¹å½¢å‘å…‰ï¼ˆå…­è¾¹å½¢ï¼‰
            const center = size / 2;
            const radius = size / 2 - 2;
            const sides = 6;
            
            ctx.beginPath();
            for (let i = 0; i <= sides; i++) {
                const angle = (Math.PI * 2 * i) / sides - Math.PI / 2;
                const x = center + radius * Math.cos(angle);
                const y = center + radius * Math.sin(angle);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            
            // å¾„å‘æ¸å˜ï¼ˆä¸­å¿ƒäº®ï¼Œè¾¹ç¼˜é€æ˜ï¼‰
            const gradient = ctx.createRadialGradient(center, center, 0, center, center, radius);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.4)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = gradient;
            ctx.fill();
            
            return new THREE.CanvasTexture(canvas);
        }

        // åˆ›å»ºç²’å­ç³»ç»Ÿï¼ˆæ”¯æŒZè½´åˆ†å±‚ï¼‰
        function createParticles(positions, colors, isEdge = null) {
            if (particlesMesh) {
                scene.remove(particlesMesh);
                particlesMesh.geometry.dispose();
                particlesMesh.material.dispose();
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            // æ·»åŠ è‡ªå®šä¹‰å±æ€§ï¼šå¤§å°ã€é€æ˜åº¦ã€é€Ÿåº¦ï¼ˆç”¨äºåŠ¨æ€è¾‰å…‰ï¼‰
            const sizes = new Float32Array(positions.length / 3);
            const opacities = new Float32Array(positions.length / 3);
            const velocities = new Float32Array(positions.length / 3);
            
            for (let i = 0; i < positions.length / 3; i++) {
                // Zè½´åˆ†å±‚ï¼šæ ¹æ®Zåæ ‡åˆ†é…å±‚
                const z = positions[i * 3 + 2];
                const normalizedZ = (z + CONFIG.sphereRadius) / (CONFIG.sphereRadius * 2);
                const layer = Math.floor(normalizedZ * CONFIG.layerCount);
                const layerProgress = (normalizedZ * CONFIG.layerCount) % 1;
                
                // è¿‘å±‚å¤§ä¸”äº®ï¼Œè¿œå±‚å°ä¸”é€æ˜
                const baseSize = CONFIG.particleSize;
                sizes[i] = baseSize * (1 - layerProgress * 0.5);
                opacities[i] = 1 - layerProgress * 0.6;
                
                // è¾¹ç¼˜ç²’å­ç‰¹æ®Šå¤„ç†
                if (isEdge && isEdge[i]) {
                    sizes[i] *= 1.2; // è¾¹ç¼˜ç²’å­ç¨å¤§
                    opacities[i] = Math.min(1, opacities[i] * CONFIG.neonOutlineBrightness);
                }
                
                velocities[i] = 0; // åˆå§‹é€Ÿåº¦
            }
            
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geometry.setAttribute('opacity', new THREE.Float32BufferAttribute(opacities, 1));
            geometry.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 1));

            // ä½¿ç”¨ShaderMaterialå®ç°æ›´é«˜çº§çš„æ•ˆæœï¼ˆå¦‚æœæ€§èƒ½å…è®¸ï¼‰
            const material = new THREE.PointsMaterial({
                size: CONFIG.particleSize,
                sizeAttenuation: true,
                map: createGlowTexture(),
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.9
            });

            particlesMesh = new THREE.Points(geometry, material);
            scene.add(particlesMesh);
        }

        // ==================== åˆ›å»ºé»˜è®¤ç²’å­æ•ˆæœ ====================
        function createDefaultParticles() {
            particleData = [];
            const positions = [];
            const colors = [];
            const isEdge = [];

            const count = CONFIG.particleCount;
            const radius = CONFIG.sphereRadius;
            
            const color1 = new THREE.Color(0x00ffff);
            const color2 = new THREE.Color(0xff00cc);

            for (let i = 0; i < count; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);

                positions.push(x, y, z);

                const alpha = (y + radius) / (radius * 2);
                const color = color1.clone().lerp(color2, alpha);
                colors.push(color.r, color.g, color.b);

                // éšæœºæ ‡è®°10%ä¸ºé—ªçƒç²’å­
                const isTwinkle = Math.random() < CONFIG.twinkleRatio;
                
                particleData.push({
                    baseX: x, baseY: y, baseZ: z,
                    x: x, y: y, z: z,
                    targetColor: { r: color.r, g: color.g, b: color.b },
                    currentColor: { r: color.r, g: color.g, b: color.b },
                    colorTransitionTime: 0,
                    isTwinkle: isTwinkle,
                    twinklePhase: Math.random() * Math.PI * 2,
                    isEdge: Math.random() < 0.15, // 15%æ ‡è®°ä¸ºè¾¹ç¼˜
                    velocity: 0, // è¿åŠ¨é€Ÿåº¦ï¼ˆç”¨äºè¾‰å…‰ï¼‰
                    noiseOffset: Math.random() * Math.PI * 2 // éšæœºå¾®éœ‡ç›¸ä½
                });
                
                isEdge.push(particleData[i].isEdge);
            }

            createParticles(positions, colors, isEdge);
            updateParticleCountDisplay();
        }

        // ==================== å›¾ç‰‡å¤„ç† ====================
        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            loadingDiv.style.display = 'block';
            animationState.isLoading = true;
            animationState.loadTime = 0;

            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    createParticlesFromImage(img);
                };
                img.onerror = function() {
                    loadingDiv.style.display = 'none';
                    animationState.isLoading = false;
                    alert('å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œè¯·é‡è¯•');
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        // ==================== ä»å›¾ç‰‡åˆ›å»ºç²’å­ï¼ˆæ”¾å°„çŠ¶æ‰©æ•£åŠ è½½åŠ¨ç”»ï¼‰ ====================
        function createParticlesFromImage(image) {
            particleData = [];

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            const maxSize = CONFIG.imageMaxSize;
            let width = image.width;
            let height = image.height;
            const scale = Math.min(1, maxSize / Math.max(width, height));
            width = Math.floor(width * scale);
            height = Math.floor(height * scale);
            
            canvas.width = width;
            canvas.height = height;
            
            ctx.drawImage(image, 0, 0, width, height);
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;

            const sphereGeo = new THREE.SphereGeometry(CONFIG.sphereRadius, 64, 64);
            const vertices = sphereGeo.attributes.position.array;
            const uvs = sphereGeo.attributes.uv.array;

            const positions = [];
            const colors = [];
            const isEdge = [];
            const particleCount = Math.min(CONFIG.particleCount, vertices.length / 3);
            const step = Math.floor(vertices.length / 3 / particleCount);

            // æ£€æµ‹è¾¹ç¼˜åƒç´ 
            const edgeMap = new Set();
            for (let py = 0; py < height; py++) {
                for (let px = 0; px < width; px++) {
                    if (isEdgePixel(data, px, py, width, height)) {
                        edgeMap.add(`${px},${py}`);
                    }
                }
            }

            for (let i = 0; i < particleCount; i++) {
                const idx = i * step * 3;
                const x = vertices[idx];
                const y = vertices[idx + 1];
                const z = vertices[idx + 2];

                const uvIdx = i * step * 2;
                const u = uvs[uvIdx];
                const v = uvs[uvIdx + 1];

                const pixelX = Math.floor(u * (width - 1));
                const pixelY = Math.floor((1 - v) * (height - 1));
                const pixelIdx = (pixelX + pixelY * width) * 4;

                // æ£€æŸ¥æ˜¯å¦ä¸ºè¾¹ç¼˜
                const isEdgeParticle = edgeMap.has(`${pixelX},${pixelY}`);
                isEdge.push(isEdgeParticle);

                // åˆå§‹ä½ç½®è®¾ä¸ºå±å¹•ä¸­å¿ƒï¼ˆç”¨äºæ”¾å°„çŠ¶æ‰©æ•£ï¼‰
                const centerX = 0;
                const centerY = 0;
                const centerZ = 0;
                positions.push(centerX, centerY, centerZ);

                // ç›®æ ‡ä½ç½®
                const targetX = x;
                const targetY = y;
                const targetZ = z;

                // ä»å›¾ç‰‡è·å–é¢œè‰²å¹¶è½¬æ¢ä¸ºHSV
                const r = data[pixelIdx] / 255;
                const g = data[pixelIdx + 1] / 255;
                const b = data[pixelIdx + 2] / 255;
                
                // HSVå¾®è°ƒï¼ˆå¢å¼ºé¥±å’Œåº¦ï¼‰
                const hsv = rgbToHsv(r * 255, g * 255, b * 255);
                hsv.s = Math.min(1, hsv.s * 1.2); // æé«˜é¥±å’Œåº¦
                const adjustedRgb = hsvToRgb(hsv.h, hsv.s, hsv.v);
                
                // è¾¹ç¼˜ç²’å­ä½¿ç”¨éœ“è™¹è‰²
                let finalR = adjustedRgb.r;
                let finalG = adjustedRgb.g;
                let finalB = adjustedRgb.b;
                
                if (isEdgeParticle && CONFIG.enableNeonOutline) {
                    // éœ“è™¹æè¾¹ï¼šè“è‰²/ç´«è‰²æ··åˆ
                    const neonMix = 0.6;
                    finalR = finalR * (1 - neonMix) + 0 * neonMix;
                    finalG = finalG * (1 - neonMix) + 0.95 * neonMix;
                    finalB = finalB * (1 - neonMix) + 1 * neonMix;
                }
                
                colors.push(finalR, finalG, finalB);

                const isTwinkle = Math.random() < CONFIG.twinkleRatio;
                
                particleData.push({
                    baseX: targetX, baseY: targetY, baseZ: targetZ,
                    x: centerX, y: centerY, z: centerZ, // åˆå§‹ä½ç½®åœ¨ä¸­å¿ƒ
                    targetColor: { r: finalR, g: finalG, b: finalB },
                    currentColor: { r: 0, g: 0, b: 0 }, // åˆå§‹é¢œè‰²ä¸ºé»‘
                    colorTransitionTime: 0,
                    isTwinkle: isTwinkle,
                    twinklePhase: Math.random() * Math.PI * 2,
                    isEdge: isEdgeParticle,
                    velocity: 0,
                    noiseOffset: Math.random() * Math.PI * 2,
                    loadDelay: Math.random() * CONFIG.loadAnimation // åŠ è½½å»¶è¿Ÿï¼ˆå®ç°æ”¾å°„çŠ¶æ‰©æ•£ï¼‰
                });
            }

            sphereGeo.dispose();
            createParticles(positions, colors, isEdge);
            updateParticleCountDisplay();
            
            // å¼€å§‹åŠ è½½åŠ¨ç”»
            animationState.loadTime = 0;
        }

        // ==================== å‚æ•°è°ƒèŠ‚ ====================
        function handleParamChange(e) {
            const btn = e.target;
            const value = parseInt(btn.dataset.value);
            
            document.querySelectorAll('.param-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            
            CONFIG.particleCount = value;
            
            if (particlesMesh) {
                createDefaultParticles();
            }
        }

        // ==================== æš‚åœ/æ¢å¤ ====================
        function togglePause() {
            isPaused = !isPaused;
            hintDiv.textContent = isPaused ? 'â¸ï¸ å·²æš‚åœ | é•¿æŒ‰æ¢å¤' : 'ğŸ‘† å•æŒ‡æ‹–æ‹½æ—‹è½¬ | ğŸ¤ åŒæŒ‡ç¼©æ”¾ | â¸ï¸ é•¿æŒ‰æš‚åœ';
            hintDiv.style.display = 'block';
            hintDiv.style.opacity = '1';
            setTimeout(() => {
                hintDiv.style.opacity = '0';
                setTimeout(() => hintDiv.style.display = 'none', 500);
            }, 2000);
        }

        // ==================== åŠ¨ç”»å¾ªç¯ ====================
        function animate() {
            requestAnimationFrame(animate);

            const currentTime = performance.now();
            const deltaTime = Math.min((currentTime - lastFrameTime) / 1000, 0.1); // é™åˆ¶æœ€å¤§deltaTime
            lastFrameTime = currentTime;

            if (!particlesMesh || isPaused) {
                // æ›´æ–°æ®‹å½±
                updateTrails(deltaTime);
                renderer.render(scene, camera);
                return;
            }

            time += CONFIG.breathingSpeed * deltaTime * 60; // æ ‡å‡†åŒ–åˆ°60fps

            // è‡ªåŠ¨æ—‹è½¬
            particlesMesh.rotation.y += CONFIG.autoRotateSpeed * deltaTime * 60;

            // å¤„ç†åŠ è½½åŠ¨ç”»
            if (animationState.isLoading) {
                animationState.loadTime += deltaTime;
                const loadProgress = Math.min(1, animationState.loadTime / CONFIG.loadAnimation);
                
                if (loadProgress >= 1) {
                    animationState.isLoading = false;
                    loadingDiv.style.display = 'none';
                }
            }

            // å¤„ç†çˆ†ç‚¸åŠ¨ç”»
            if (animationState.isExploding) {
                animationState.explosionTime += deltaTime;
                const progress = Math.min(1, animationState.explosionTime / CONFIG.explosionDuration);
                
                if (progress >= 1) {
                    animationState.isExploding = false;
                }
            }

            // å¤„ç†ç¼©æ”¾åŠ¨ç”»ï¼ˆå¼¹æ€§æ•ˆæœï¼‰
            if (animationState.zoomTarget !== null) {
                animationState.zoomTime += deltaTime;
                const progress = Math.min(1, animationState.zoomTime / CONFIG.zoomAnimation);
                
                // å¼¹æ€§ç¼“åŠ¨å‡½æ•°
                const eased = 1 - Math.pow(1 - progress, 3);
                const currentDist = lerp(animationState.zoomStart, animationState.zoomTarget, eased);
                
                camera.position.normalize().multiplyScalar(currentDist);
                camera.lookAt(0, 0, 0);
                
                if (progress >= 1) {
                    animationState.zoomTarget = null;
                }
            }

            // æ›´æ–°ç²’å­
            const positions = particlesMesh.geometry.attributes.position.array;
            const colorArray = particlesMesh.geometry.attributes.color.array;
            const breatheFactor = 1 + Math.sin(time * 5) * CONFIG.breathingRange;

            for (let i = 0; i < particleData.length; i++) {
                const data = particleData[i];
                
                // åŠ è½½åŠ¨ç”»ï¼šæ”¾å°„çŠ¶æ‰©æ•£
                if (animationState.isLoading) {
                    const loadProgress = Math.min(1, (animationState.loadTime - data.loadDelay) / (CONFIG.loadAnimation - data.loadDelay));
                    if (loadProgress > 0 && loadProgress < 1) {
                        const eased = 1 - Math.pow(1 - loadProgress, 2); // easeOut
                        data.x = lerp(0, data.baseX, eased);
                        data.y = lerp(0, data.baseY, eased);
                        data.z = lerp(0, data.baseZ, eased);
                    } else if (loadProgress >= 1) {
                        data.x = data.baseX;
                        data.y = data.baseY;
                        data.z = data.baseZ;
                    }
                }
                // çˆ†ç‚¸åŠ¨ç”»
                else if (animationState.isExploding && data.explosionVelocity) {
                    const progress = Math.min(1, animationState.explosionTime / CONFIG.explosionDuration);
                    const eased = 1 - progress; // ä»1åˆ°0
                    
                    const explosionDist = eased * 50; // çˆ†ç‚¸è·ç¦»
                    data.x = data.explosionStart.x + data.explosionVelocity.x * eased;
                    data.y = data.explosionStart.y + data.explosionVelocity.y * eased;
                    data.z = data.explosionStart.z + data.explosionVelocity.z * eased;
                    
                    // çˆ†ç‚¸åå›å½’
                    if (progress < 0.7) {
                        const returnProgress = (0.7 - progress) / 0.7;
                        data.x += (data.baseX - data.x) * (1 - returnProgress) * 0.1;
                        data.y += (data.baseY - data.y) * (1 - returnProgress) * 0.1;
                        data.z += (data.baseZ - data.z) * (1 - returnProgress) * 0.1;
                    }
                }
                // æ­£å¸¸å‘¼å¸+éšæœºå¾®éœ‡
                else {
                    const targetX = data.baseX * breatheFactor;
                    const targetY = data.baseY * breatheFactor;
                    const targetZ = data.baseZ * breatheFactor;
                    
                    // éšæœºå¾®éœ‡ï¼ˆå¸ƒæœ—è¿åŠ¨ï¼‰
                    const noiseX = Math.sin(time * 2 + data.noiseOffset) * 2;
                    const noiseY = Math.cos(time * 2.3 + data.noiseOffset) * 2;
                    const noiseZ = Math.sin(time * 1.7 + data.noiseOffset) * 2;
                    
                    data.x += (targetX + noiseX - data.x) * 0.1;
                    data.y += (targetY + noiseY - data.y) * 0.1;
                    data.z += (targetZ + noiseZ - data.z) * 0.1;
                    
                    // è®¡ç®—é€Ÿåº¦ï¼ˆç”¨äºåŠ¨æ€è¾‰å…‰ï¼‰
                    const dx = data.x - (positions[i * 3] || data.x);
                    const dy = data.y - (positions[i * 3 + 1] || data.y);
                    const dz = data.z - (positions[i * 3 + 2] || data.z);
                    data.velocity = Math.sqrt(dx * dx + dy * dy + dz * dz);
                }

                positions[i * 3] = data.x;
                positions[i * 3 + 1] = data.y;
                positions[i * 3 + 2] = data.z;

                // è‰²å½©è¿‡æ¸¡åŠ¨ç”»
                data.colorTransitionTime += deltaTime;
                if (data.colorTransitionTime < CONFIG.colorTransition) {
                    const t = data.colorTransitionTime / CONFIG.colorTransition;
                    data.currentColor.r = lerp(data.currentColor.r, data.targetColor.r, t);
                    data.currentColor.g = lerp(data.currentColor.g, data.targetColor.g, t);
                    data.currentColor.b = lerp(data.currentColor.b, data.targetColor.b, t);
                } else {
                    data.currentColor = { ...data.targetColor };
                }

                // é—ªçƒæ•ˆæœï¼ˆ10%çš„ç²’å­ï¼‰
                let brightness = 1;
                if (data.isTwinkle && CONFIG.enableTwinkle) {
                    const twinkle = Math.sin(time * 0.5 + data.twinklePhase) * 0.5 + 0.5;
                    brightness = 0.5 + twinkle * 0.5; // 50%-100%
                }

                // åŠ¨æ€è¾‰å…‰ï¼ˆé€Ÿåº¦è¶Šå¿«è¶Šäº®ï¼‰
                const glowFactor = 1 + Math.min(data.velocity * 0.1, 0.3);
                brightness *= glowFactor;

                // åº”ç”¨é¢œè‰²å’Œäº®åº¦
                colorArray[i * 3] = data.currentColor.r * brightness;
                colorArray[i * 3 + 1] = data.currentColor.g * brightness;
                colorArray[i * 3 + 2] = data.currentColor.b * brightness;
            }

            particlesMesh.geometry.attributes.position.needsUpdate = true;
            particlesMesh.geometry.attributes.color.needsUpdate = true;

            // æ›´æ–°æ®‹å½±
            updateTrails(deltaTime);

            // æ¨ªå±ä¼˜åŒ–ï¼šè°ƒæ•´ç²’å­å¤§å°
            const isLandscape = window.innerWidth > window.innerHeight;
            if (isLandscape && particlesMesh.material) {
                particlesMesh.material.size = CONFIG.particleSize * 1.2;
            } else if (particlesMesh.material) {
                particlesMesh.material.size = CONFIG.particleSize;
            }

            renderer.render(scene, camera);
        }

        // ==================== æ›´æ–°æ®‹å½± ====================
        function updateTrails(deltaTime) {
            if (!CONFIG.enableTrail) return;
            
            for (let i = trailSystem.trails.length - 1; i >= 0; i--) {
                const trail = trailSystem.trails[i];
                trail.time += deltaTime;
                trail.opacity -= CONFIG.trailFade * deltaTime;
                
                if (trail.opacity <= 0) {
                    scene.remove(trail.mesh);
                    trail.mesh.geometry.dispose();
                    trail.mesh.material.dispose();
                    trailSystem.trails.splice(i, 1);
                } else {
                    trail.mesh.material.opacity = trail.opacity;
                }
            }
        }

        // ==================== çª—å£å¤§å°æ”¹å˜ ====================
        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        // ==================== æ›´æ–°ç²’å­æ•°é‡æ˜¾ç¤º ====================
        function updateParticleCountDisplay() {
            particleCountDiv.textContent = `ç²’å­: ${particleData.length}`;
        }

        // ==================== å¯åŠ¨ ====================
        init();
    </script>
</body>
</html>